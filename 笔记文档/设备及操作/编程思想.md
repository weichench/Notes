## 二分查找法

查找某个数字或统计某个数字的个数，都可考虑二分查找法

s，m，e

**根据m来更新s与e。更新后，得到新的m，进而继续** ——是m，不用分成m，m+1

```c++
初始化，s，e
while(e>s)
{  m = (s+e)/2;
   if(待查找的在前半区间)  //根据题设，考虑先判断前半部分，还是后半部分
       e = m;
   else   //在后半区间
       s=m;

}

```



__________

## 二维数组

处理前，先判断是否为空

**关键特殊的地方，边角的元素**

要使用数组a[8],    那么数组的长度必然是 **int *a = new int[8+1];**

______________

**当需要在一个连续的数据结构（比如数组）中添加新的内容， 可以先直接算出最终元素的位置，然后从后往前，一步到位**

____

## 递归——本质上是一种栈结构——首先就应考虑终止条件

递归的每一次调用，都要在内存栈中保存参数、局部变量、返回地址——这消耗了额外的空间。而且，数据的压入与弹出都需要时间——故而空间与时间的效率也不高。递归调用的次数也不可过多，否则，内存栈可能会溢出。

+ 一种递归——反向输出链表
+ 另一种——二叉树重建

如果一个递归里边有两次递归调用，则最终的调用次数将绘制2^n+2^(n-1)+2^(n-2)+……————调用次数过多，效率极差

________

## 二叉树——中序遍历

对于二叉树的中序遍历，若有右树，则下一个会去到右树环节

+ 如果一个节点有右子节点，则其下一个被遍历的节点是右子树的最左节点
+ 如果没有右树
  + 其如果是父节点的左子节点，其下一个节点就是父节点
  + 其是父节点的右子节点，需要向上遍历，直到找到一个节点时其父节点的左子节点，则那个父节点就是他的下一个节点，当然，找到根节点还没有找到，那就说明这个节点已经是最后一个节点了

```

it->left->next;     // 链表或二叉树的访问，不要这个样子，会出错
//这样分开操作
pnode = it->left;
pnode->next;
```

________

# 排序

**不同的场景，适合不同的算法**

## 快速排序法——不适合小型数组——复杂度分析？

+ 先得需要一个函数pation——用于在数组中任选一个元素，使得数组中左半部分的元素全部小于这个值，右半部分的元素，全部大于这个值
  + 具体操作的话，就是将那个选中的元素先直接放到最后边。然后，交换数组中的元素，使得比这个值小的元素都往前交换; 完成一次遍历，则小的全部在前半部分，大的在后半部分。
+ 定义递归程序，递归终止的条件是，子数组仅含一个元素。先对数组的前半部分递归操作排序，在对数组的后半部分递归排序



## 对一定范围的值进行排序

**使用O(n)的辅助内存，实现时间复杂度为O(n)的排序——统计每个元素出现的次数，然后出现的次数，对该数组进行重新编排，实现排序**



## 冒泡法排序

两层循环，一个一个往出冒

________

## 回朔——递归调用程序里边会有多次的并列的递归调用——相当于是在被并列的同层次的叶子节点进行递归



## 回朔———寻找一个确定的解决方案

遍历是否可以通过递归得到结果，如果这一步没有得到，则继续循环，下一次遍历;一旦找到结果，则直接跳出遍历结束

## 回朔的递归调用部分

递归终止有两种条件，一个是全部成功的条件——找到了解决办法; 另一个是本次递归无解的情况，如果某些条件不再满足，则意味着本次递归失败终止。一般在成功判断与失败判断的中间部分，是递归调用部分



## 回朔——寻找所有可能的解决途径

在主程序里边，从初始条件开始，直接进入递归;

在递归调用程序里边，首先给出一个一次递归终止的条件;然后判断是否可以进行递归调用，对所有可能的条件，进行递归调用。



___________

## 动态规划——

求问题最优解，整体的最优解可分为子部分的最优解  ， 小问题之间有相互重叠的部分，  

自上而下的分解问题，自下而上的求解问题——可以先将重复的小问题求解出来存储，避免重复求解

尝试所有的解法，比较找到最优解



把一个问题分解成两部分，比如，把8分成两部分，

```c++
for(int i = 1; i<=8/2; i++)   //i不用增长到8,因为（1,7）跟（7，1）是一样的，后半部分就重复了
{}
```



_____________

## 贪婪算法——每一步都做出最贪婪的选择

____________

## 位运算

程序里边的一个数，直接也可以看成时二进制数，比如，

```
if( n & 1 )     //可以得到n的最后一位是否为1, 
```

位运算的运算符为 **&， |， ^ ———— 区别于逻辑运算的 &&   ||  **       

+ 原码，最高位为符号位， [1111 1111 , 0111 1111]        [-127 , 127]

+ 反码  正数的反码是其本身

  负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.    [-1] = [10000001]原 = [11111110]反

+ 补码。 正数的补码就是其本身

  ​     负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

     [-1] = [10000001]原 = [11111110]反 = [11111111]补

## 补码，是为了将符号位直接参与运算（机器并不能直接判断一个数的正负）

____________

## 输入要考虑异常值，正数，0, 负数都要考虑的



__________

## 数值

判断瓣double是否为0,，或者两个double是否接近

**if（abs（a - b ） < 1e(-6) ）,**    

_______

## 两个指针操作链表

**利用两个指针，可以构建一个确定长度的范围，可用于连续的数据结构中，比如数组或链表——类似于一个滑动窗口**

### 比如利用该该方法，可以找到链表中倒数第K个节点



## 一块一慢两个指针

**找到链表的中间节点，两个指针，一个一次往前走一步，一个一次往前走两步，则后一个指针始终在头个指针的中间位置——直到头一个找到表尾**



**在环状链表中，两个一快一慢的指针必然会相遇————可用于判断链表中是否有环——相遇的节点必然在环内**

**使用定长范围的窗口，可以找到链表的入口节点**

________

## 对称

**从左往右与从右往左是一样的**

_________

## 条件判断

```c++
  if(pRoot1 == nullptr && pRoot2 == nullptr)     //是否同时为空
         return true;              
     if(pRoot1 == nullptr || pRoot2 == nullptr)  //必然是一空一实 
         return false;
     if(pRoot1->val != pRoot2->val)   // 必然都不为空
         return false;
```



______

**对于一些较为复杂的操作，在表示控制变量时，将i，j，k这种控制变量命名为具体的，能表明实际意义的变量，**

**比如，表示当前层的个数 current_num, nex_num   ,这样的命名，更有助于理解过程**



**所以，不要用i，j，k这样的命名，用直观的命名方式——来自于JZ60的经验**

